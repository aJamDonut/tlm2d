<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Character Class Test Suite</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .test-panel {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .controls-panel {
            background-color: #2c3e50;
            padding: 20px;
            border-radius: 8px;
            height: fit-content;
        }
        
        .canvas-container {
            background-color: #34495e;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        
        .control-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #34495e;
        }
        
        .control-section:last-child {
            border-bottom: none;
        }
        
        .control-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #3498db;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        
        select, input, button {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            background-color: #34495e;
            color: white;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        button {
            background-color: #3498db;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        button.success {
            background-color: #27ae60;
        }
        
        button.success:hover {
            background-color: #229954;
        }
        
        button.danger {
            background-color: #e74c3c;
        }
        
        button.danger:hover {
            background-color: #c0392b;
        }
        
        button.warning {
            background-color: #f39c12;
        }
        
        button.warning:hover {
            background-color: #e67e22;
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .button-group-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
        }
        
        .info-display {
            background-color: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .log-container {
            background-color: #2c3e50;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .log-output {
            background-color: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            height: 200px;
            overflow-y: auto;
            border: 1px solid #34495e;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }
        
        .log-success { color: #2ecc71; }
        .log-error { color: #e74c3c; }
        .log-warning { color: #f39c12; }
        .log-info { color: #3498db; }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-loaded { background-color: #2ecc71; }
        .status-error { background-color: #e74c3c; }
        .status-loading { background-color: #f39c12; }
        .status-empty { background-color: #95a5a6; }
        
        #gameCanvas {
            border: 2px solid #34495e;
            border-radius: 8px;
        }
        
        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .metric {
            background-color: #34495e;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 18px;
            font-weight: bold;
            color: #3498db;
        }
        
        .metric-label {
            font-size: 12px;
            color: #bdc3c7;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß™ Character Class Test Suite</h1>
            <p>Comprehensive testing environment for the Character class</p>
        </div>
        
        <div class="test-panel">
            <div class="controls-panel">
                <div class="control-section">
                    <h3>üìÅ Character Loading</h3>
                    
                    <div class="control-group">
                        <label for="characterSelect">Character:</label>
                        <select id="characterSelect">
                            <option value="Survivor 3">Survivor 3</option>
                            <option value="Thug1">Thug1</option>
                            <option value="Thug2">Thug2</option>
                            <option value="Thug3">Thug3</option>
                            <option value="Thug4">Thug4</option>
                            <option value="Thug5">Thug5</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label for="animationSelect">Animation:</label>
                        <select id="animationSelect">
                            <option value="Idle">Idle</option>
                            <option value="Run">Run</option>
                            <option value="Walk">Walk</option>
                            <option value="Attack1">Attack1</option>
                            <option value="Attack2">Attack2</option>
                            <option value="Attack3">Attack3</option>
                            <option value="Attack4">Attack4</option>
                            <option value="Die">Die</option>
                            <option value="Taunt">Taunt</option>
                            <option value="CrouchIdle">CrouchIdle</option>
                            <option value="CrouchRun">CrouchRun</option>
                            <option value="TakeDamage">TakeDamage</option>
                            <option value="RunAttack">RunAttack</option>
                            <option value="RunBackwards">RunBackwards</option>
                            <option value="StrafeLeft">StrafeLeft</option>
                            <option value="StrafeRight">StrafeRight</option>
                        </select>
                    </div>
                    
                    <div class="button-group">
                        <button id="loadCharacter" class="success">Load Character</button>
                        <button id="changeAnimation">Change Anim</button>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>üß≠ Direction Control</h3>
                    
                    <div class="control-group">
                        <label for="directionSelect">Direction:</label>
                        <select id="directionSelect">
                            <option value="0">Right (0¬∞)</option>
                            <option value="1">Down-Right (45¬∞)</option>
                            <option value="2">Down (90¬∞)</option>
                            <option value="3">Down-Left (135¬∞)</option>
                            <option value="4">Left (180¬∞)</option>
                            <option value="5">Up-Left (225¬∞)</option>
                            <option value="6">Up (270¬∞)</option>
                            <option value="7">Up-Right (315¬∞)</option>
                        </select>
                    </div>
                    
                    <div class="button-group">
                        <button id="rotateClockwise">Rotate CW</button>
                        <button id="rotateCounterClockwise">Rotate CCW</button>
                    </div>
                    
                    <button id="autoRotate" class="warning">Auto Rotate</button>
                </div>
                
                <div class="control-section">
                    <h3>‚ö° Animation Control</h3>
                    
                    <div class="control-group">
                        <label for="speedSlider">Speed: <span id="speedValue">0.1</span></label>
                        <input type="range" id="speedSlider" min="0.01" max="0.5" step="0.01" value="0.1">
                    </div>
                    
                    <div class="control-group">
                        <label for="scaleSlider">Scale: <span id="scaleValue">3</span></label>
                        <input type="range" id="scaleSlider" min="0.5" max="6" step="0.1" value="3">
                    </div>
                    
                    <div class="button-group">
                        <button id="playAnimation" class="success">Play</button>
                        <button id="stopAnimation" class="danger">Stop</button>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>üìç Position Control</h3>
                    
                    <div class="control-group">
                        <label for="xPosition">X Position:</label>
                        <input type="number" id="xPosition" value="400" min="0" max="800">
                    </div>
                    
                    <div class="control-group">
                        <label for="yPosition">Y Position:</label>
                        <input type="number" id="yPosition" value="300" min="0" max="600">
                    </div>
                    
                    <button id="applyPosition">Apply Position</button>
                    <button id="centerCharacter">Center</button>
                </div>
                
                <div class="control-section">
                    <h3>üß™ Advanced Tests</h3>
                    
                    <button id="loadMultiple" class="success">Load Multiple</button>
                    <button id="stressTest" class="warning">Stress Test</button>
                    <button id="animationSequence">Animation Sequence</button>
                    <button id="errorTest" class="danger">Error Test</button>
                    <button id="clearAll" class="danger">Clear All</button>
                </div>
                
                <div class="control-section">
                    <h3>üìä Character Info</h3>
                    <div class="info-display" id="characterInfo">No character loaded</div>
                    <button id="refreshInfo">Refresh Info</button>
                </div>
            </div>
            
            <div class="canvas-container">
                <div id="gameCanvas"></div>
                
                <div class="performance-metrics">
                    <div class="metric">
                        <div class="metric-value" id="fpsCounter">0</div>
                        <div class="metric-label">FPS</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="characterCount">0</div>
                        <div class="metric-label">Characters</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="memoryUsage">0</div>
                        <div class="metric-label">Textures</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="loadTime">0ms</div>
                        <div class="metric-label">Load Time</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="log-container">
            <h3>üìù Test Log</h3>
            <div class="log-output" id="logOutput"></div>
            <div class="button-group-3">
                <button id="clearLog">Clear Log</button>
                <button id="exportLog">Export Log</button>
                <button id="runAllTests" class="success">Run All Tests</button>
            </div>
        </div>
    </div>

    <!-- Load PixiJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    
    <!-- Character Test Suite -->
    <script type="module">
        import { Character } from '../src/character.js';
        
        class CharacterTestSuite {
            constructor() {
                this.app = null;
                this.currentCharacter = null;
                this.allCharacters = [];
                this.testLog = [];
                this.autoRotateInterval = null;
                this.performanceStats = {
                    fps: 0,
                    characterCount: 0,
                    textureCount: 0,
                    lastLoadTime: 0
                };
                
                this.init();
            }
            
            async init() {
                this.log('üöÄ Initializing Character Test Suite...', 'info');
                
                // Create PixiJS app
                this.app = new PIXI.Application({
                    width: 1000,
                    height: 600,
                    backgroundColor: 0x34495e,
                    antialias: true
                });
                
                document.getElementById('gameCanvas').appendChild(this.app.view);
                
                // Setup performance monitoring
                this.setupPerformanceMonitoring();
                
                // Setup event listeners
                this.setupEventListeners();
                
                this.log('‚úÖ Test suite initialized successfully', 'success');
                this.updateCharacterInfo();
            }
            
            setupPerformanceMonitoring() {
                let frameCount = 0;
                let lastTime = performance.now();
                
                this.app.ticker.add(() => {
                    frameCount++;
                    const currentTime = performance.now();
                    
                    if (currentTime - lastTime >= 1000) {
                        this.performanceStats.fps = Math.round(frameCount * 1000 / (currentTime - lastTime));
                        frameCount = 0;
                        lastTime = currentTime;
                        this.updatePerformanceDisplay();
                    }
                    
                    this.performanceStats.characterCount = this.allCharacters.length;
                    this.performanceStats.textureCount = this.app.renderer.texture.managedTextures.length;
                });
            }
            
            setupEventListeners() {
                // Character loading
                document.getElementById('loadCharacter').addEventListener('click', () => {
                    this.testLoadCharacter();
                });
                
                document.getElementById('changeAnimation').addEventListener('click', () => {
                    this.testChangeAnimation();
                });
                
                // Direction control
                document.getElementById('directionSelect').addEventListener('change', (e) => {
                    this.testSetDirection(parseInt(e.target.value));
                });
                
                document.getElementById('rotateClockwise').addEventListener('click', () => {
                    this.testRotateDirection(1);
                });
                
                document.getElementById('rotateCounterClockwise').addEventListener('click', () => {
                    this.testRotateDirection(-1);
                });
                
                document.getElementById('autoRotate').addEventListener('click', () => {
                    this.testAutoRotate();
                });
                
                // Animation control
                document.getElementById('speedSlider').addEventListener('input', (e) => {
                    const speed = parseFloat(e.target.value);
                    document.getElementById('speedValue').textContent = speed.toFixed(2);
                    this.testSetAnimationSpeed(speed);
                });
                
                document.getElementById('scaleSlider').addEventListener('input', (e) => {
                    const scale = parseFloat(e.target.value);
                    document.getElementById('scaleValue').textContent = scale.toFixed(1);
                    this.testSetScale(scale);
                });
                
                document.getElementById('playAnimation').addEventListener('click', () => {
                    this.testPlayAnimation();
                });
                
                document.getElementById('stopAnimation').addEventListener('click', () => {
                    this.testStopAnimation();
                });
                
                // Position control
                document.getElementById('applyPosition').addEventListener('click', () => {
                    const x = parseInt(document.getElementById('xPosition').value);
                    const y = parseInt(document.getElementById('yPosition').value);
                    this.testSetPosition(x, y);
                });
                
                document.getElementById('centerCharacter').addEventListener('click', () => {
                    this.testCenterCharacter();
                });
                
                // Advanced tests
                document.getElementById('loadMultiple').addEventListener('click', () => {
                    this.testLoadMultiple();
                });
                
                document.getElementById('stressTest').addEventListener('click', () => {
                    this.testStressTest();
                });
                
                document.getElementById('animationSequence').addEventListener('click', () => {
                    this.testAnimationSequence();
                });
                
                document.getElementById('errorTest').addEventListener('click', () => {
                    this.testErrorHandling();
                });
                
                document.getElementById('clearAll').addEventListener('click', () => {
                    this.testClearAll();
                });
                
                // Info and logging
                document.getElementById('refreshInfo').addEventListener('click', () => {
                    this.updateCharacterInfo();
                });
                
                document.getElementById('clearLog').addEventListener('click', () => {
                    this.clearLog();
                });
                
                document.getElementById('exportLog').addEventListener('click', () => {
                    this.exportLog();
                });
                
                document.getElementById('runAllTests').addEventListener('click', () => {
                    this.runAllTests();
                });
            }
            
            async testLoadCharacter() {
                const startTime = performance.now();
                const characterName = document.getElementById('characterSelect').value;
                const animationType = document.getElementById('animationSelect').value;
                
                this.log(`üîÑ Loading character: ${characterName} - ${animationType}`, 'info');
                
                try {
                    // Clear current character
                    if (this.currentCharacter) {
                        this.currentCharacter.destroy();
                        this.removeFromAllCharacters(this.currentCharacter);
                    }
                    
                    // Create new character
                    this.currentCharacter = new Character();
                    
                    // Setup event listeners for testing
                    this.setupCharacterEventListeners(this.currentCharacter);
                    
                    // Load character
                    const success = await this.currentCharacter.loadCharacter(characterName, animationType);
                    
                    if (success) {
                        // Position and add to stage
                        this.currentCharacter.setPosition(500, 300);
                        this.app.stage.addChild(this.currentCharacter.sprite);
                        this.allCharacters.push(this.currentCharacter);
                        
                        const loadTime = performance.now() - startTime;
                        this.performanceStats.lastLoadTime = Math.round(loadTime);
                        
                        this.log(`‚úÖ Character loaded successfully in ${this.performanceStats.lastLoadTime}ms`, 'success');
                        this.updateCharacterInfo();
                    } else {
                        this.log(`‚ùå Failed to load character`, 'error');
                    }
                    
                } catch (error) {
                    this.log(`‚ùå Error loading character: ${error.message}`, 'error', error);
                }
            }
            
            async testChangeAnimation() {
                if (!this.currentCharacter) {
                    this.log(`‚ö†Ô∏è No character loaded for animation change test`, 'warning');
                    return;
                }
                
                const animationType = document.getElementById('animationSelect').value;
                this.log(`üé¨ Changing animation to: ${animationType}`, 'info');
                
                const success = await this.currentCharacter.changeAnimation(animationType);
                
                if (success) {
                    // Ensure the sprite is still in the stage after recreation
                    this.currentCharacter.addToContainer(this.app.stage);
                    this.log(`‚úÖ Animation changed successfully`, 'success');
                    this.updateCharacterInfo();
                } else {
                    this.log(`‚ùå Failed to change animation`, 'error');
                }
            }
            
            testSetDirection(direction) {
                if (!this.currentCharacter) {
                    this.log(`‚ö†Ô∏è No character loaded for direction test`, 'warning');
                    return;
                }
                
                this.currentCharacter.setDirection(direction);
                const directionName = this.currentCharacter.getDirectionName(direction);
                this.log(`üß≠ Direction set to: ${directionName} (${direction})`, 'success');
                this.updateCharacterInfo();
            }
            
            testRotateDirection(step) {
                if (!this.currentCharacter) {
                    this.log(`‚ö†Ô∏è No character loaded for rotation test`, 'warning');
                    return;
                }
                
                const currentDir = this.currentCharacter.currentDirection;
                const newDir = (currentDir + step + 8) % 8;
                
                this.currentCharacter.setDirection(newDir);
                document.getElementById('directionSelect').value = newDir;
                
                const directionName = this.currentCharacter.getDirectionName(newDir);
                this.log(`üîÑ Rotated to: ${directionName}`, 'success');
                this.updateCharacterInfo();
            }
            
            testAutoRotate() {
                if (!this.currentCharacter) {
                    this.log(`‚ö†Ô∏è No character loaded for auto-rotate test`, 'warning');
                    return;
                }
                
                if (this.autoRotateInterval) {
                    clearInterval(this.autoRotateInterval);
                    this.autoRotateInterval = null;
                    this.log(`‚èπÔ∏è Auto-rotate stopped`, 'info');
                    document.getElementById('autoRotate').textContent = 'Auto Rotate';
                } else {
                    this.autoRotateInterval = setInterval(() => {
                        this.testRotateDirection(1);
                    }, 800);
                    this.log(`‚ñ∂Ô∏è Auto-rotate started`, 'info');
                    document.getElementById('autoRotate').textContent = 'Stop Auto Rotate';
                }
            }
            
            testSetAnimationSpeed(speed) {
                if (!this.currentCharacter) {
                    this.log(`‚ö†Ô∏è No character loaded for speed test`, 'warning');
                    return;
                }
                
                this.currentCharacter.setAnimationSpeed(speed);
                this.log(`‚ö° Animation speed set to: ${speed.toFixed(2)}`, 'success');
                this.updateCharacterInfo();
            }
            
            testSetScale(scale) {
                if (!this.currentCharacter) {
                    this.log(`‚ö†Ô∏è No character loaded for scale test`, 'warning');
                    return;
                }
                
                this.currentCharacter.setScale(scale);
                this.log(`üîç Scale set to: ${scale.toFixed(1)}`, 'success');
                this.updateCharacterInfo();
            }
            
            testPlayAnimation() {
                if (!this.currentCharacter) {
                    this.log(`‚ö†Ô∏è No character loaded for play test`, 'warning');
                    return;
                }
                
                this.currentCharacter.play();
                this.log(`‚ñ∂Ô∏è Animation playing`, 'success');
            }
            
            testStopAnimation() {
                if (!this.currentCharacter) {
                    this.log(`‚ö†Ô∏è No character loaded for stop test`, 'warning');
                    return;
                }
                
                this.currentCharacter.stop();
                this.log(`‚èπÔ∏è Animation stopped`, 'success');
            }
            
            testSetPosition(x, y) {
                if (!this.currentCharacter) {
                    this.log(`‚ö†Ô∏è No character loaded for position test`, 'warning');
                    return;
                }
                
                this.currentCharacter.setPosition(x, y);
                this.log(`üìç Position set to: (${x}, ${y})`, 'success');
                this.updateCharacterInfo();
            }
            
            testCenterCharacter() {
                if (!this.currentCharacter) {
                    this.log(`‚ö†Ô∏è No character loaded for center test`, 'warning');
                    return;
                }
                
                const centerX = this.app.screen.width / 2;
                const centerY = this.app.screen.height / 2;
                
                this.currentCharacter.setPosition(centerX, centerY);
                document.getElementById('xPosition').value = centerX;
                document.getElementById('yPosition').value = centerY;
                
                this.log(`üéØ Character centered at (${centerX}, ${centerY})`, 'success');
                this.updateCharacterInfo();
            }
            
            async testLoadMultiple() {
                this.log(`üîÑ Testing multiple character loading...`, 'info');
                
                const configs = [
                    { name: 'Survivor 3', animation: 'Idle', position: { x: 200, y: 150 }, direction: 0 },
                    { name: 'Thug1', animation: 'Run', position: { x: 500, y: 150 }, direction: 4 },
                    { name: 'Thug2', animation: 'Attack1', position: { x: 800, y: 150 }, direction: 2 },
                    { name: 'Thug3', animation: 'Walk', position: { x: 200, y: 450 }, direction: 6 },
                    { name: 'Thug4', animation: 'Taunt', position: { x: 800, y: 450 }, direction: 1 }
                ];
                
                try {
                    const characters = await Character.loadMultiple(configs);
                    
                    characters.forEach(character => {
                        this.setupCharacterEventListeners(character);
                        this.app.stage.addChild(character.sprite);
                        this.allCharacters.push(character);
                    });
                    
                    this.log(`‚úÖ Loaded ${characters.length} characters successfully`, 'success');
                    
                } catch (error) {
                    this.log(`‚ùå Error in multiple loading: ${error.message}`, 'error');
                }
            }
            
            async testStressTest() {
                this.log(`üî• Starting stress test...`, 'warning');
                
                const characters = [];
                const maxCharacters = 20;
                
                for (let i = 0; i < maxCharacters; i++) {
                    const character = new Character();
                    const characterName = `Thug${(i % 5) + 1}`;
                    const animations = ['Idle', 'Run', 'Walk', 'Attack1'];
                    const animation = animations[i % animations.length];
                    
                    const success = await character.loadCharacter(characterName, animation);
                    
                    if (success) {
                        character.setPosition(
                            Math.random() * 900 + 50,
                            Math.random() * 500 + 50
                        );
                        character.setDirection(Math.floor(Math.random() * 8));
                        character.setScale(Math.random() * 2 + 1);
                        
                        this.app.stage.addChild(character.sprite);
                        characters.push(character);
                        this.allCharacters.push(character);
                    }
                }
                
                this.log(`üî• Stress test completed: ${characters.length} characters loaded`, 'success');
            }
            
            async testAnimationSequence() {
                if (!this.currentCharacter) {
                    this.log(`‚ö†Ô∏è No character loaded for sequence test`, 'warning');
                    return;
                }
                
                this.log(`üé¨ Starting animation sequence test...`, 'info');
                
                const sequence = [
                    { animation: 'Taunt', direction: 2, duration: 2000 },
                    { animation: 'Run', direction: 0, duration: 1500 },
                    { animation: 'Attack1', direction: 4, duration: 2000 },
                    { animation: 'Die', direction: 6, duration: 3000 },
                    { animation: 'Idle', direction: 2, duration: 1000 }
                ];
                
                for (const step of sequence) {
                    await this.currentCharacter.changeAnimation(step.animation);
                    if (step.direction !== undefined) {
                        this.currentCharacter.setDirection(step.direction);
                        document.getElementById('directionSelect').value = step.direction;
                    }
                    this.log(`üé≠ Sequence: ${step.animation} for ${step.duration}ms`, 'info');
                    this.updateCharacterInfo();
                    
                    await this.wait(step.duration);
                }
                
                this.log(`‚úÖ Animation sequence completed`, 'success');
            }
            
            async testErrorHandling() {
                this.log(`üö® Testing error handling...`, 'warning');
                
                const character = new Character();
                
                // Test invalid character
                let success = await character.loadCharacter('InvalidCharacter', 'Idle');
                this.log(`‚ùå Invalid character test: ${success ? 'FAILED' : 'PASSED'}`, success ? 'error' : 'success');
                
                // Test invalid animation
                success = await character.loadCharacter('Survivor 3', 'InvalidAnimation');
                this.log(`‚ùå Invalid animation test: ${success ? 'FAILED' : 'PASSED'}`, success ? 'error' : 'success');
                
                // Test invalid direction
                if (this.currentCharacter) {
                    this.currentCharacter.setDirection(99);
                    this.log(`‚ùå Invalid direction test completed`, 'success');
                }
                
                this.log(`‚úÖ Error handling tests completed`, 'success');
            }
            
            testClearAll() {
                this.log(`üóëÔ∏è Clearing all characters...`, 'warning');
                
                if (this.autoRotateInterval) {
                    clearInterval(this.autoRotateInterval);
                    this.autoRotateInterval = null;
                }
                
                this.allCharacters.forEach(character => {
                    character.destroy();
                });
                
                this.allCharacters = [];
                this.currentCharacter = null;
                
                this.log(`‚úÖ All characters cleared`, 'success');
                this.updateCharacterInfo();
            }
            
            async runAllTests() {
                this.log(`üöÄ Running comprehensive test suite...`, 'info');
                
                // Clear existing
                this.testClearAll();
                await this.wait(500);
                
                // Basic loading test
                await this.testLoadCharacter();
                await this.wait(1000);
                
                // Animation change test
                document.getElementById('animationSelect').value = 'Run';
                await this.testChangeAnimation();
                await this.wait(1000);
                
                // Direction tests
                for (let i = 0; i < 8; i++) {
                    this.testSetDirection(i);
                    await this.wait(300);
                }
                
                // Speed and scale tests
                this.testSetAnimationSpeed(0.2);
                await this.wait(500);
                this.testSetScale(4);
                await this.wait(500);
                
                // Multiple character test
                await this.testLoadMultiple();
                await this.wait(1000);
                
                // Error handling test
                await this.testErrorHandling();
                
                this.log(`üéâ All tests completed successfully!`, 'success');
            }
            
            setupCharacterEventListeners(character) {
                character.on('loaded', (data) => {
                    this.log(`üì° Event: Character loaded - ${data.characterName}`, 'info');
                });
                
                character.on('animationChanged', (data) => {
                    this.log(`üì° Event: Animation changed to ${data.animationType}`, 'info');
                });
                
                character.on('spriteCreated', (data) => {
                    this.log(`üì° Event: Sprite recreated for direction ${data.direction}`, 'info');
                    // Ensure sprite is in stage after recreation
                    if (character.getSprite() && !character.getSprite().parent) {
                        this.app.stage.addChild(character.getSprite());
                        this.log(`üîß Auto-added sprite back to stage`, 'info');
                    }
                });
                
                character.on('directionChanged', (data) => {
                    this.log(`üì° Event: Direction changed to ${character.getDirectionName(data.direction)}`, 'info');
                });
                
                character.on('speedChanged', (data) => {
                    this.log(`üì° Event: Speed changed to ${data.speed.toFixed(2)}`, 'info');
                });
                
                character.on('error', (data) => {
                    this.log(`üì° Event: Error - ${data.error.message}`, 'error');
                });
            }
            
            removeFromAllCharacters(character) {
                const index = this.allCharacters.indexOf(character);
                if (index > -1) {
                    this.allCharacters.splice(index, 1);
                }
            }
            
            updateCharacterInfo() {
                const infoElement = document.getElementById('characterInfo');
                
                if (this.currentCharacter) {
                    const info = this.currentCharacter.getInfo();
                    const sprite = this.currentCharacter.getSprite();
                    infoElement.innerHTML = `
Character: ${info.characterName || 'None'}
Animation: ${info.animationType || 'None'}
Direction: ${info.directionName} (${info.direction})
Speed: ${info.animationSpeed.toFixed(2)}
Position: (${sprite?.x || 0}, ${sprite?.y || 0})
Scale: ${sprite?.scale?.x || 1}
Playing: ${info.isPlaying ? 'Yes' : 'No'}
Loaded: ${info.isLoaded ? 'Yes' : 'No'}
In Stage: ${sprite?.parent ? 'Yes' : 'No'}`.trim();
                } else {
                    infoElement.textContent = 'No character loaded';
                }
            }
            
            updatePerformanceDisplay() {
                document.getElementById('fpsCounter').textContent = this.performanceStats.fps;
                document.getElementById('characterCount').textContent = this.performanceStats.characterCount;
                document.getElementById('memoryUsage').textContent = this.performanceStats.textureCount;
                document.getElementById('loadTime').textContent = `${this.performanceStats.lastLoadTime}ms`;
            }
            
            log(message, type = 'info', error) {
                console.error(error)
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = { timestamp, message, type };
                this.testLog.push(logEntry);
                
                const logOutput = document.getElementById('logOutput');
                const logElement = document.createElement('div');
                logElement.className = `log-entry log-${type}`;
                logElement.textContent = `[${timestamp}] ${message}`;
                
                logOutput.appendChild(logElement);
                logOutput.scrollTop = logOutput.scrollHeight;
                
                // Console logging for debugging
                console.log(`[${timestamp}] ${message}`);
            }
            
            clearLog() {
                this.testLog = [];
                document.getElementById('logOutput').innerHTML = '';
                this.log('üìù Log cleared', 'info');
            }
            
            exportLog() {
                const logText = this.testLog.map(entry => 
                    `[${entry.timestamp}] ${entry.type.toUpperCase()}: ${entry.message}`
                ).join('\n');
                
                const blob = new Blob([logText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `character-test-log-${Date.now()}.txt`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.log('üìÅ Log exported successfully', 'success');
            }
            
            wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }
        
        // Initialize the test suite
        window.addEventListener('DOMContentLoaded', () => {
            window.testSuite = new CharacterTestSuite();
        });
    </script>
</body>
</html>